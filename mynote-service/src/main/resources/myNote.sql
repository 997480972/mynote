/*
Navicat MySQL Data Transfer

Source Server         : windows
Source Server Version : 50711
Source Host           : 192.168.1.67:3306
Source Database       : liu

Target Server Type    : MYSQL
Target Server Version : 50711
File Encoding         : 65001

Date: 2018-01-20 11:26:59
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `category`
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', '2017-11-28 16:25:50', '设计模式');
INSERT INTO `category` VALUES ('2', '2017-11-28 16:40:37', 'spring-boot');
INSERT INTO `category` VALUES ('3', '2017-11-28 16:51:46', 'vue.js');
INSERT INTO `category` VALUES ('4', '2017-11-28 17:08:30', 'js');
INSERT INTO `category` VALUES ('5', '2017-11-28 17:10:46', 'FreeMarker');
INSERT INTO `category` VALUES ('6', '2017-11-28 17:18:04', 'JVM');
INSERT INTO `category` VALUES ('7', '2017-11-28 17:30:33', 'Maven');
INSERT INTO `category` VALUES ('8', '2017-11-28 17:32:52', 'Mysql');
INSERT INTO `category` VALUES ('9', '2017-11-28 17:33:11', 'eclipse');
INSERT INTO `category` VALUES ('10', '2017-11-28 17:33:38', 'Git');
INSERT INTO `category` VALUES ('11', '2017-11-28 17:36:43', 'Linux');
INSERT INTO `category` VALUES ('12', '2017-11-28 18:17:59', 'Redis');
INSERT INTO `category` VALUES ('13', '2017-11-28 18:20:38', '工具类');
INSERT INTO `category` VALUES ('14', '2017-11-28 18:23:46', '多线程');
INSERT INTO `category` VALUES ('15', '2017-11-28 18:24:54', 'Java');

-- ----------------------------
-- Table structure for `note`
-- ----------------------------
DROP TABLE IF EXISTS `note`;
CREATE TABLE `note` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `author` varchar(255) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  `category_name` varchar(255) DEFAULT NULL,
  `content` text NOT NULL,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `description` varchar(255) DEFAULT NULL,
  `show_count` int(11) DEFAULT NULL,
  `status` int(11) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `update_time` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of note
-- ----------------------------
INSERT INTO `note` VALUES ('2', '', null, '', '<p style=\"text-align:left;\">\n	<br />\n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">Spring Boot&nbsp;</span><span style=\"color:#555555;\">默认为我们提供了静态资源处理，使用</span><span style=\"color:#555555;\">WebMvcAutoConfiguration&nbsp;</span><span style=\"color:#555555;\">中的配置各种属性。</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">建议大家使用</span><span style=\"color:#555555;\">SpringBoot</span><span style=\"color:#555555;\">的默认配置方式，如果需要特殊处理的再通过配置进行修改。</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">如果想要自己完全控制</span><span style=\"color:#555555;\">WebMVC</span><span style=\"color:#555555;\">，就需要在</span><span style=\"color:#555555;\">@Configuration</span><span style=\"color:#555555;\">注解的配置类上增加</span><span style=\"color:#555555;\">@EnableWebMvc</span><span style=\"color:#555555;\">（</span><span style=\"color:#555555;\">@SpringBootApplication</span><span style=\"color:#555555;\">注解的程序入口类已经包含</span><span style=\"color:#555555;\">@Configuration</span><span style=\"color:#555555;\">），增加该注解以后</span><span style=\"color:#555555;\">WebMvcAutoConfiguration</span><span style=\"color:#555555;\">中配置就不会生效，你需要自己来配置需要的每一项。这种情况下的配置还是要多看一下</span><span style=\"color:#555555;\">WebMvcAutoConfiguration</span><span style=\"color:#555555;\">类。</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">我们既然是快速使用</span><span style=\"color:#555555;\">Spring Boot</span><span style=\"color:#555555;\">，并不想过多的自己再重新配置。本文还是主要针对</span><span style=\"color:#555555;\">Spring Boot</span><span style=\"color:#555555;\">的默认处理方式，部分配置在</span><span style=\"color:#555555;\">application&nbsp;</span><span style=\"color:#555555;\">配置文件中（</span><span style=\"color:#555555;\">.properties&nbsp;</span><span style=\"color:#555555;\">或</span><span style=\"color:#555555;\">&nbsp;.yml</span><span style=\"color:#555555;\">）</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">&nbsp;</span> \n</p>\n<h2 style=\"color:#333333;font-family:Arial;background-color:#FFFFFF;\">\n	<a name=\"t0\"></a><span style=\"color:#555555;\">默认资源映射</span> \n</h2>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">我们在启动应用的时候，可以在控制台中看到如下信息：</span> \n</p>\n<pre>2016-01-0809:29:30<span style=\"color:#9B703F;\">.362</span>&nbsp;INFO24932---<span style=\"color:#008800;\">[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main]</span>o<span style=\"color:#9B703F;\">.s.w.s.handler.SimpleUrlHandlerMapping</span>&nbsp; :MappedURLpath<span style=\"color:#008800;\">[/webjars/**]</span>ontohandleroftype<span style=\"color:#008800;\">[class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span></pre>\n<pre>2016-01-0809:29:30<span style=\"color:#9B703F;\">.362</span>&nbsp;INFO24932---<span style=\"color:#008800;\">[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main]</span>o<span style=\"color:#9B703F;\">.s.w.s.handler.SimpleUrlHandlerMapping</span>&nbsp; :MappedURLpath<span style=\"color:#008800;\">[/**]</span>ontohandleroftype<span style=\"color:#008800;\">[class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span></pre>\n<pre>2016-01-0809:29:30<span style=\"color:#9B703F;\">.437</span>&nbsp;INFO24932---<span style=\"color:#008800;\">[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main]</span>o<span style=\"color:#9B703F;\">.s.w.s.handler.SimpleUrlHandlerMapping</span>&nbsp; :MappedURLpath<span style=\"color:#008800;\">[/**/favicon.ico]</span>ont</pre>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">其中默认配置的</span><span style=\"color:#555555;\">&nbsp;/**&nbsp;</span><span style=\"color:#555555;\">映射到</span><span style=\"color:#555555;\">&nbsp;/static&nbsp;</span><span style=\"color:#555555;\">（或</span><span style=\"color:#555555;\">/public</span><span style=\"color:#555555;\">、</span><span style=\"color:#555555;\">/resources</span><span style=\"color:#555555;\">、</span><span style=\"color:#555555;\">/META-INF/resources</span><span style=\"color:#555555;\">）</span><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\"><br />\n</span><span style=\"color:#555555;\">其中默认配置的</span><span style=\"color:#555555;\">&nbsp;/webjars/**&nbsp;</span><span style=\"color:#555555;\">映射到</span><span style=\"color:#555555;\">&nbsp;classpath:/META-INF/resources/webjars/&nbsp;</span><br />\nPS<span style=\"color:#555555;\">：上面的</span><span style=\"color:#555555;\">&nbsp;static</span><span style=\"color:#555555;\">、</span><span style=\"color:#555555;\">public</span><span style=\"color:#555555;\">、</span><span style=\"color:#555555;\">resources&nbsp;</span><span style=\"color:#555555;\">等目录都在</span><span style=\"color:#555555;\">&nbsp;classpath:&nbsp;</span><span style=\"color:#555555;\">下面（如</span><span style=\"color:#555555;\">&nbsp;src/main/resources/static</span><span style=\"color:#555555;\">）。</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">如果我按如下结构存放相同名称的图片，那么</span><span style=\"color:#555555;\">SpringBoot&nbsp;</span><span style=\"color:#555555;\">读取图片的优先级是怎样的呢？</span><span style=\"color:#555555;\">&nbsp;</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">如下图：</span><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\"><br />\n</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">当我们访问地址</span><span style=\"color:#555555;\">&nbsp;</span><a target=\"_blank\" href=\"http://localhost:8080/test.jpg\">http://localhost:8080/test.jpg</a><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\">的时候，显示哪张图片？这里可以直接告诉大家，优先级顺序为：</span><span style=\"color:#555555;\">META/resources &gt; resources &gt; static &gt;public&nbsp; (</span><span style=\"color:red;\">已进行测试</span><span style=\"color:#555555;\">)</span><span style=\"color:#555555;\"><br />\n</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">如果我们想访问</span><span style=\"color:#555555;\">test2.jpg</span><span style=\"color:#555555;\">，请求地址</span><span style=\"color:#555555;\">&nbsp;</span><a target=\"_blank\" href=\"http://localhost:8080/img/test2.jpg\">http://localhost:8080/img/test2.jpg</a> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	&nbsp;\n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">&nbsp;</span> \n</p>\n<h2 style=\"color:#333333;font-family:Arial;background-color:#FFFFFF;\">\n	<a name=\"t1\"></a><span style=\"color:#555555;\">自定义资源映射</span> \n</h2>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">上面我们介绍了</span><span style=\"color:#555555;\">Spring Boot&nbsp;</span><span style=\"color:#555555;\">的默认资源映射，一般够用了，那我们如何自定义目录？</span><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\"><br />\n</span><span style=\"color:#555555;\">这些资源都是打包在</span><span style=\"color:#555555;\">jar</span><span style=\"color:#555555;\">包中的，然后实际应用中，我们还有很多资源是在管理系统中动态维护的，并不可能在程序包中，对于这种随意指定目录的资源，如何访问？</span> \n</p>\n<h3 style=\"color:#333333;font-family:Arial;background-color:#FFFFFF;\">\n	<a name=\"t2\"></a><span style=\"color:#555555;\">自定义目录</span> \n</h3>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">以增加</span><span style=\"color:#555555;\">/myres/<em>*&nbsp;</em></span><em><span style=\"color:#555555;\">映射到</span><span style=\"color:#555555;\">&nbsp;classpath:/myres/*</span></em><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\">为例的代码处理为：</span><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\"><br />\n</span><span style=\"color:#555555;\">实现类继承</span><span style=\"color:#555555;\">&nbsp;WebMvcConfigurerAdapter&nbsp;</span><span style=\"color:#555555;\">并重写方法</span><span style=\"color:#555555;\">&nbsp;addResourceHandlers&nbsp;</span><span style=\"color:#555555;\">（对于</span> \n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background:#D9D9D9;\">\n<pre class=\"prettyprint lang-java\">package org.springboot.sample.config;\n \nimport org.springboot.sample.interceptor.MyInterceptor1;\nimport org.springboot.sample.interceptor.MyInterceptor2;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n \n@Configuration\npublic class MyWebAppConfigurer\n        extendsWebMvcConfigurerAdapter {\n \n    @Override\n    public voidaddResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"/myres/**\").addResourceLocations(\"classpath:/myres/\");\n        super.addResourceHandlers(registry);\n    }\n \n}</pre>\n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background:#D9D9D9;\">\n	<br />\n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">访问</span><span style=\"color:#555555;\">myres&nbsp;</span><span style=\"color:#555555;\">文件夹中的</span><span style=\"color:#555555;\">test.jpg&nbsp;</span><span style=\"color:#555555;\">图片的地址为</span><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\"><a target=\"_blank\" href=\"http://localhost:8080/myres/test.jpg\">http://localhost:8080/myres/test.jpg</a>&nbsp;</span><br />\n<span style=\"color:#555555;\">这样使用代码的方式自定义目录映射，并不影响</span><span style=\"color:#555555;\">Spring Boot</span><span style=\"color:#555555;\">的默认映射，可以同时使用。</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">如果我们将</span><span style=\"color:#555555;\">/myres/<em>*&nbsp;</em></span><em><span style=\"color:#555555;\">修改为</span><span style=\"color:#555555;\">&nbsp;/*</span></em><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\">与默认的相同时，则会覆盖系统的配置，可以多次使用</span><span style=\"color:#555555;\">&nbsp;addResourceLocations&nbsp;</span><span style=\"color:#555555;\">添加目录，优先级先添加的高于后添加的。</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">其中</span><span style=\"color:#555555;\">addResourceLocations&nbsp;</span><span style=\"color:#555555;\">的参数是动参，可以这样写</span><span style=\"color:#555555;\">addResourceLocations(“classpath:/img1/”, “classpath:/img2/”,“classpath:/img3/”);</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">&nbsp;</span> \n</p>\n<h3 style=\"color:#333333;font-family:Arial;background-color:#FFFFFF;\">\n	<a name=\"t3\"></a><span style=\"color:#555555;\">使用外部目录</span> \n</h3>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">如果我们要指定一个绝对路径的文件夹（如</span><span style=\"color:#555555;\">&nbsp;D:/data/api_files&nbsp;</span><span style=\"color:#555555;\">），则只需要使用</span><span style=\"color:#555555;\">&nbsp;addResourceLocations&nbsp;</span><span style=\"color:#555555;\">指定即可。</span> \n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	//&nbsp;可以直接使用addResourceLocations&nbsp;指定磁盘绝对路径，同样可以配置多个位置，注意路径写法需要加上file:\n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	registry<span style=\"color:#444444;\">.addResourceHandler</span>(<span style=\"color:#008800;\">\"/api_files/**\"</span>)<span style=\"color:#444444;\">.addResourceLocations</span>(<span style=\"color:#008800;\">\"file:D:/data/api_files\"</span>)<span style=\"color:#880000;\">;</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">&nbsp;</span> \n</p>\n<h2 style=\"color:#333333;font-family:Arial;background-color:#FFFFFF;\">\n	<a name=\"t4\"></a><span style=\"color:#555555;\">通过配置文件配置</span> \n</h2>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">上面是使用代码来定义静态资源的映射，其实</span><span style=\"color:#555555;\">Spring Boot</span><span style=\"color:#555555;\">也为我们提供了可以直接在</span><span style=\"color:#555555;\">application.properties</span><span style=\"color:#555555;\">（或</span><span style=\"color:#555555;\">.yml</span><span style=\"color:#555555;\">）中配置的方法。</span><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\"><br />\n</span><span style=\"color:#555555;\">配置方法如下：</span> \n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#444444;\">&nbsp;</span><span style=\"color:#444444;\">默认值为</span><span style=\"color:#444444;\">&nbsp;/**</span> \n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	spring.mvc.<span style=\"color:#000088;\">static</span>-path-pattern=\n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#444444;\">#&nbsp;</span><span style=\"color:#444444;\">默认值为</span><span style=\"color:#444444;\">classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	spring.resources.<span style=\"color:#000088;\">static</span>-locations=这里设置要指向的路径，多个使用英文逗号隔开，\n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">使用</span><span style=\"color:#555555;\">spring.mvc.static-path-pattern&nbsp;</span><span style=\"color:#555555;\">可以重新定义</span><span style=\"color:#555555;\">pattern</span><span style=\"color:#555555;\">，如修改为</span><span style=\"color:#555555;\">&nbsp;/myres/**&nbsp;</span><span style=\"color:#555555;\">，则访问</span><span style=\"color:#555555;\">static&nbsp;</span><span style=\"color:#555555;\">等目录下的</span><span style=\"color:#555555;\">fengjing.jpg</span><span style=\"color:#555555;\">文件应该为</span><a target=\"_blank\" href=\"http://localhost:8080/myres/fengjing.jpg\"><span style=\"color:#0C89CF;\">http://localhost:8080/myres/fengjing.jpg</span></a><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\">，修改之前为</span><span style=\"color:#555555;\">&nbsp;</span><a target=\"_blank\" href=\"http://localhost:8080/fengjing.jpg\"><span style=\"color:#0C89CF;\">http://localhost:8080/fengjing.jpg</span></a><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\"><br />\n</span><span style=\"color:#555555;\">使用</span><span style=\"color:#555555;\">&nbsp;spring.resources.static-locations&nbsp;</span><span style=\"color:#555555;\">可以重新定义</span><span style=\"color:#555555;\">&nbsp;pattern&nbsp;</span><span style=\"color:#555555;\">所指向的路径，支持</span><span style=\"color:#555555;\">&nbsp;classpath:&nbsp;</span><span style=\"color:#555555;\">和</span><span style=\"color:#555555;\">&nbsp;file:&nbsp;</span><span style=\"color:#555555;\">（上面已经做过说明）</span><span style=\"color:#555555;\">&nbsp;</span><span style=\"color:#555555;\"><br />\n</span><span style=\"color:#555555;\">注意</span><span style=\"color:#555555;\">&nbsp;spring.mvc.static-path-pattern&nbsp;</span><span style=\"color:#555555;\">只可以定义一个，目前不支持多个逗号分割的方式。</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">&nbsp;</span> \n</p>\n<h3 style=\"color:#333333;font-family:Arial;background-color:#FFFFFF;\">\n	<a name=\"t5\"></a><span style=\"color:#555555;\">页面中使用</span> \n</h3>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">上面几个例子中也已经说明了怎么访问静态资源，其实在页面中使用不管是</span><span style=\"color:#555555;\">jsp</span><span style=\"color:#555555;\">还是</span><span style=\"color:#555555;\">freemarker</span><span style=\"color:#555555;\">，并没有什么特殊之处，也我们平时开发</span><span style=\"color:#555555;\">web</span><span style=\"color:#555555;\">项目一样即可。</span><span style=\"color:#555555;\">&nbsp;</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#555555;\">下面是我的</span><span style=\"color:#555555;\">index.jsp</span><span style=\"color:#555555;\">：</span> \n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#006666;\">&lt;</span><span style=\"color:#000088;\">body</span><span style=\"color:#006666;\">&gt;</span> \n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#006666;\">&lt;</span><span style=\"color:#000088;\">img</span><span style=\"color:#660066;\">alt</span><span style=\"color:#006666;\">=</span><span style=\"color:#008800;\">\"</span><span style=\"color:#008800;\">读取默认配置中的图片</span><span style=\"color:#008800;\">\"</span><span style=\"color:#660066;\">src</span><span style=\"color:#006666;\">=</span><span style=\"color:#008800;\">\"${pageContext.request.contextPath}/pic.jpg\"</span><span style=\"color:#006666;\">&gt;</span> \n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#006666;\">&lt;</span><span style=\"color:#000088;\">br</span><span style=\"color:#006666;\">/&gt;</span> \n</p>\n<p align=\"left\" style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color:#006666;\">&lt;</span><span style=\"color:#000088;\">img</span><span style=\"color:#660066;\">alt</span><span style=\"color:#006666;\">=</span><span style=\"color:#008800;\">\"</span><span style=\"color:#008800;\">读取自定义配置</span><span style=\"color:#008800;\">myres</span><span style=\"color:#008800;\">中的图片</span><span style=\"color:#008800;\">\"</span><span style=\"color:#660066;\">src</span><span style=\"color:#006666;\">=</span><span style=\"color:#008800;\">\"${pageContext.request.contextPath}/myres/fengjing.jpg\"</span><span style=\"color:#006666;\">&gt;</span> \n</p>\n<p style=\"color:#333333;font-family:Arial;font-size:14px;background-color:#FFFFFF;\">\n	<span style=\"color:#006666;\">&lt;/</span><span style=\"color:#000088;\">body</span><span style=\"color:#006666;\">&gt;</span> \n</p>\n<div>\n	<br />\n</div>\n<p>\n	<br />\n</p>\n<p style=\"text-align:center;\">\n	<br />\n</p>', '2017-09-01 15:45:17', '', null, null, ' 处理静态资源【从零开始学Spring Boot】', '');
INSERT INTO `note` VALUES ('3', '', null, '', '<p>\n	fg\n</p>', '2017-09-01 15:53:19', '', null, null, '33', '');
INSERT INTO `note` VALUES ('4', null, null, null, '<p>44</p>', '2017-09-01 15:57:56', null, null, null, '4', null);
INSERT INTO `note` VALUES ('5', '', null, '', '<p>ad&nbsp;</p>', '2017-09-01 16:04:59', '', null, null, '22', '');
INSERT INTO `note` VALUES ('6', 'author', '1', 'java', 'content', '2017-09-22 11:33:07', 'description', '0', '1', 'javaNote', null);
INSERT INTO `note` VALUES ('7', '', null, '', '<p>asdf sadf&nbsp;</p><p>safd&nbsp;</p>', '2017-09-01 16:12:12', '', null, null, 'saf sadf ', '');
INSERT INTO `note` VALUES ('8', null, null, null, '<p>88<br/></p><p>8</p><p>8</p><p><br/></p><p>8</p><p>8</p><p>8</p><p><br/></p><p>8</p>', '2017-09-04 11:17:57', null, null, null, '8', null);
INSERT INTO `note` VALUES ('9', null, null, null, '<p><br/></p><h1 style=\"border-bottom-color:#cccccc;border-bottom-width:2px;border-bottom-style:solid;padding:0px 4px 0px 0px;text-align:center;margin:0px 0px 20px;\" class=\"ue_t\">[此处键入文章标题]</h1><p><img src=\"http://img.baidu.com/hi/youa/y_0034.gif\" width=\"300\" height=\"200\"/>图文混排方法</p><p>1. 图片居左，文字围绕图片排版</p><p>方法：在文字前面插入图片，设置居左对齐，然后即可在右边输入多行文本</p><p><br/></p><p>2. 图片居右，文字围绕图片排版</p><p>方法：在文字前面插入图片，设置居右对齐，然后即可在左边输入多行文本</p><p><br/></p><p>3. 图片居中环绕排版</p><p>方法：亲，这个真心没有办法。。。</p><p><br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/youa/y_0040.gif\" width=\"300\" height=\"300\"/></p><p>还有没有什么其他的环绕方式呢？这里是居右环绕</p><p><br/></p><p>欢迎大家多多尝试，为UEditor提供更多高质量模板！</p><p><br/></p><p>占位</p><p><br/></p><p>占位</p><p><br/></p><p>占位</p><p><br/></p><p>占位</p><p><br/></p><p>占位</p><p><br/></p><p><br/></p><p><br/></p>', '2017-09-04 11:19:46', null, null, null, '9', null);
INSERT INTO `note` VALUES ('10', null, null, null, '<p><img width=\"520\" height=\"340\" src=\"http://maps.googleapis.com/maps/api/staticmap?center=39.93944692354029,116.39745889999995&zoom=8&size=520x340&maptype=roadmap&markers=39.90419989999999,116.40739630000007&sensor=false\"/></p>', '2017-09-15 14:42:21', null, null, null, '666', null);
INSERT INTO `note` VALUES ('12', null, null, null, '<p>14:46:172017-09-15</p><hr/><p><img width=\"520\" height=\"340\" src=\"http://maps.googleapis.com/maps/api/staticmap?center=39.93944692354029,116.39745889999995&zoom=8&size=520x340&maptype=roadmap&markers=39.90419989999999,116.40739630000007&sensor=false\"/><br/></p><p style=\"display:none;\"><br/></p>', '2017-09-15 14:46:39', null, null, null, '666', null);
INSERT INTO `note` VALUES ('13', '', null, '', '<p>\n	地方\n</p>', '2017-11-27 15:09:21', '', null, null, '666', '');
INSERT INTO `note` VALUES ('14', '', null, '', '<p>\n	就 个\n</p>', '2017-11-27 15:09:02', '', null, null, '666', '');
INSERT INTO `note` VALUES ('21', '', null, '', '<p>\n	离开就离开\n</p>', '2017-09-15 18:29:50', '', null, null, '他4', '');
INSERT INTO `note` VALUES ('22', '', null, '', '<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;作者：zuoxiaolong8810（左潇龙），转载请注明出处。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 遵循着中心思想通俗易懂，我们首先来回顾一下单例模式为何要出现，又或者说什么样的类可以做成单例的。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在我的工作过程中，我发现所有可以使用单例模式的类都有一个共性，那就是这个类没有自己的状态，换句话说，这些类无论你实例化多少个，其实都是一样的，而且更重要的一点是，这个类如果有两个或者两个以上的实例的话，我的程序竟然会产生程序错误或者与现实相违背的逻辑错误。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这样的话，如果我们不将这个类控制成单例的结构，应用中就会存在很多一模一样的类实例，这会非常浪费系统的内存资源，而且容易导致错误甚至一定会产生错误，所以我们单例模式所期待的目标或者说使用它的目的，是为了尽可能的节约内存空间，减少无谓的GC消耗，并且使应用可以正常运作。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 我稍微总结一下，一般一个类能否做成单例，最容易区别的地方就在于，这些类，在应用中如果有两个或者两个以上的实例会引起错误，又或者我换句话说，就是这些类，在整个应用中，同一时刻，有且只能有一种状态。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;一般实践当中，有很多应用级别的资源会被做成单例，比如配置文件信息，逻辑上来讲，整个应用有且只能在同在时间有一个，当然如果你有多个，这可能并不会引起程序级别错误，这里指的错误特指异常或者ERROR。但是当我们试图改变配置文件的时候，问题就出来了。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 你有两种选择，第一种，将所有的实例全部更新成一模一样的状态。第二种，就是等着出现问题。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 然而出现的问题大部分是逻辑层次上的错误，个人觉得这是比程序错误更加严重的错误，因为它不会告诉你空指针，不会告诉你非法参数，很多时候要等到影响到客户使用时才会被发现。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 下面，我们就来看一下做成单例的几种方式。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 第一种方式，我们来看一下最标准也是最原始的单例模式的构造方式。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">[java]&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">view plain</span></a><span style=\"font-size:16px;\">&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">copy</span></a> \n</div>\n<ol>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//一个静态的实例&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Singleton&nbsp;singleton;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//私有化构造函数&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton(){}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//给出一个公共的静态方法返回一个单一实例&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getInstance(){&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(singleton&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singleton&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;singleton;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">}&nbsp;&nbsp;</span>\n	</li>\n</ol>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这是在不考虑并发访问的情况下标准的单例模式的构造方式，这种方式通过几个地方来限制了我们取到的实例是唯一的。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;1.静态实例，带有static关键字的属性在每一个类中都是唯一的。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.限制客户端随意创造实例，即私有化构造方法，此为保证单例的最重要的一步。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.给一个公共的获取实例的静态方法，注意，是静态的方法，因为这个方法是在我们未获取到实例的时候就要提供给客户端调用的，所以如果是非静态的话，那就变成一个矛盾体了，因为非静态的方法必须要拥有实例才可以调用。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.判断只有持有的静态实例为null时才调用构造方法创造一个实例，否则就直接返回。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 假如你去面试一家公司，给了你一道题，让你写出一个单例模式的例子，那么如果你是刚出大学校门的学生，你能写出上面这种示例，假设我是面试官的话，满分100的话，我会给90分，剩下的那10分算是给更优秀的人一个更高的台阶。但如果你是一个有过两三年工作经验的人，如果你写出上面的示例，我估计我最多给你30分，甚至心情要是万一不好的话可能会一分不给。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;为什么同样的示例放到不同的人身上差别会这么大，就是因为前面我提到的那个情况，在不考虑并发访问的情况下，上述示例是没有问题的。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;至于为什么在并发情况下上述的例子是不安全的呢，我在这里给各位制造了一个并发的例子，用来说明，上述情况的单例模式，是有可能造出来多个实例的，我自己</span><a href=\"http://lib.csdn.net/base/softwaretest\"><span style=\"font-size:16px;\">测试</span></a><span style=\"font-size:16px;\">了约莫100次左右，最多的一次，竟然造出了3个实例。下面给出代码，大约运行10次（并发是具有概率性的，10次只是保守估计，也可能一次，也可能100次）就会发现我们创造了不只一个实例。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">[java]&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">view plain</span></a><span style=\"font-size:16px;\">&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">copy</span></a> \n</div>\n<ol>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">import&nbsp;java.util.Collections;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">import&nbsp;java.util.HashSet;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">import&nbsp;java.util.Set;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">import&nbsp;java.util.concurrent.ExecutorService;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">import&nbsp;java.util.concurrent.Executors;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">public&nbsp;class&nbsp;TestSingleton&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;lock&nbsp;;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isLock()&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;lock;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setLock(boolean&nbsp;lock)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lock&nbsp;=&nbsp;lock;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;InterruptedException&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Set&lt;String&gt;&nbsp;instanceSet&nbsp;=&nbsp;Collections.synchronizedSet(new&nbsp;HashSet&lt;String&gt;());&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;TestSingleton&nbsp;lock&nbsp;=&nbsp;new&nbsp;TestSingleton();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.setLock(true);&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecutorService&nbsp;executorService&nbsp;=&nbsp;Executors.newCachedThreadPool();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;100;&nbsp;i++)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executorService.execute(new&nbsp;Runnable()&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(true)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!lock.isLock())&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singleton&nbsp;singleton&nbsp;=&nbsp;Singleton.getInstance();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instanceSet.add(singleton.toString());&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(5000);&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.setLock(false);&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(5000);&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"------并发情况下我们取到的实例------\");&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(String&nbsp;instance&nbsp;:&nbsp;instanceSet)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(instance);&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executorService.shutdown();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">}&nbsp;&nbsp;</span>\n	</li>\n</ol>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;我在程序中同时开启了100个线程，去访问getInstance方法，并且把获得实例的toString方法获得的实例字符串装入一个同步的set集合，set集合会自动去重，所以看结果如果输出了两个或者两个以上的实例字符串，就说明我们在并发访问的过程中产生了多个实例。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;程序当中让main线程睡眠了两次，第一次是为了给足够的时间让100个线程全部开启，第二个是将锁打开以后，保证所有的线程都已经调用了getInstance方法。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;好了，这下我们用事实说明了，上述的单例写法，我们是可以创造出多个实例的，至于为什么在这里要稍微解释一下，虽说我一直都喜欢用事实说话，包括看书的时候，我也不喜欢作者跟我解释为什么，而是希望给我一个例子，让我自己去印证。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 造成这种情况的原因是因为，当并发访问的时候，第一个调用getInstance方法的线程A，在判断完singleton是null的时候，线程A就进入了if块准备创造实例，但是同时另外一个线程B在线程A还未创造出实例之前，就又进行了singleton是否为null的判断，这时singleton依然为null，所以线程B也会进入if块去创造实例，这时问题就出来了，有两个线程都进入了if块去创造实例，结果就造成单例模式并非单例。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 为了避免这种情况，我们就要考虑并发的情况了，我们最容易想到的方式应该是下面这样的方式，直接将整个方法同步。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">[java]&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">view plain</span></a><span style=\"font-size:16px;\">&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">copy</span></a> \n</div>\n<ol>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">public&nbsp;class&nbsp;BadSynchronizedSingleton&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//一个静态的实例&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;BadSynchronizedSingleton&nbsp;synchronizedSingleton;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//私有化构造函数&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;BadSynchronizedSingleton(){}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//给出一个公共的静态方法返回一个单一实例&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;synchronized&nbsp;static&nbsp;BadSynchronizedSingleton&nbsp;getInstance(){&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(synchronizedSingleton&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronizedSingleton&nbsp;=&nbsp;new&nbsp;BadSynchronizedSingleton();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;synchronizedSingleton;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">}&nbsp;&nbsp;</span>\n	</li>\n</ol>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;上面的做法很简单，就是将整个获取实例的方法同步，这样在一个线程访问这个方法时，其它所有的线程都要处于挂起等待状态，倒是避免了刚才同步访问创造出多个实例的危险，但是我只想说，这样的设计实在是糟糕透了，这样会造成很多无谓的等待，所以为了表示我的愤怒，我在类名上加入Bad。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;其实我们同步的地方只是需要发生在单例的实例还未创建的时候，在实例创建以后，获取实例的方法就没必要再进行同步控制了，所以我们将上面的示例改为很多教科书中标准的单例模式版本，也称为双重加锁。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">[java]&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">view plain</span></a><span style=\"font-size:16px;\">&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">copy</span></a> \n</div>\n<ol>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">public&nbsp;class&nbsp;SynchronizedSingleton&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//一个静态的实例&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;SynchronizedSingleton&nbsp;synchronizedSingleton;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//私有化构造函数&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;SynchronizedSingleton(){}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;//给出一个公共的静态方法返回一个单一实例&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;SynchronizedSingleton&nbsp;getInstance(){&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(synchronizedSingleton&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(SynchronizedSingleton.class)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(synchronizedSingleton&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronizedSingleton&nbsp;=&nbsp;new&nbsp;SynchronizedSingleton();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;synchronizedSingleton;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">}&nbsp;&nbsp;</span>\n	</li>\n</ol>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这种做法与上面那种最无脑的同步做法相比就要好很多了，因为我们只是在当前实例为null，也就是实例还未创建时才进行同步，否则就直接返回，这样就节省了很多无谓的线程等待时间，值得注意的是在同步块中，我们再次判断了synchronizedSingleton是否为null，解释下为什么要这样做。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;假设我们去掉同步块中的是否为null的判断，有这样一种情况，假设A线程和B线程都在同步块外面判断了synchronizedSingleton为null，结果A线程首先获得了线程锁，进入了同步块，然后A线程会创造一个实例，此时synchronizedSingleton已经被赋予了实例，A线程退出同步块，直接返回了第一个创造的实例，此时B线程获得线程锁，也进入同步块，此时A线程其实已经创造好了实例，B线程正常情况应该直接返回的，但是因为同步块里没有判断是否为null，直接就是一条创建实例的语句，所以B线程也会创造一个实例返回，此时就造成创造了多个实例的情况。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 经过刚才的分析，貌似上述双重加锁的示例看起来是没有问题了，但如果再进一步深入考虑的话，其实仍然是有问题的。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果我们深入到JVM中去探索上面这段代码，它就有可能（注意，只是有可能）是有问题的。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为虚拟机在执行创建实例的这一步操作的时候，其实是分了好几步去进行的，也就是说创建一个新的对象并非是原子性操作。在有些JVM中上述做法是没有问题的，但是有些情况下是会造成莫名的错误。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首先要明白在JVM创建新的对象时，主要要经过三步。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;1.分配内存</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.初始化构造器</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.将对象指向分配的内存的地址</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 这种顺序在上述双重加锁的方式是没有问题的，因为这种情况下JVM是完成了整个对象的构造才将内存的地址交给了对象。但是如果2和3步骤是相反的（2和3可能是相反的是因为JVM会针对字节码进行调优，而其中的一项调优便是调整指令的执行顺序），就会出现问题了。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 因为这时将会先将内存地址赋给对象，针对上述的双重加锁，就是说先将分配好的内存地址指给synchronizedSingleton，然后再进行初始化构造器，这时候后面的线程去请求getInstance方法时，会认为synchronizedSingleton对象已经实例化了，直接返回一个引用。如果在初始化构造器之前，这个线程使用了synchronizedSingleton，就会产生莫名的错误。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;所以我们在语言级别无法完全避免错误的发生，我们只有将该任务交给JVM，所以有一种比较标准的单例模式。如下所示。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">[java]&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">view plain</span></a><span style=\"font-size:16px;\">&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">copy</span></a> \n</div>\n<ol>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">package&nbsp;com.oneinstance;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">public&nbsp;class&nbsp;InnerClassSingleton&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getInstance(){&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Singleton.singleton;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;class&nbsp;Singleton{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;static&nbsp;Singleton&nbsp;singleton&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">}&nbsp;&nbsp;</span>\n	</li>\n</ol>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首先来说一下，这种方式为何会避免了上面莫名的错误，主要是因为一个类的静态属性只会在第一次加载类时初始化，这是JVM帮我们保证的，所以我们无需担心并发访问的问题。所以在初始化进行一半的时候，别的线程是无法使用的，因为JVM会帮我们强行同步这个过程。另外由于静态变量只初始化一次，所以singleton仍然是单例的。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上面这种写法是我们使用静态的内部类作为单例，这样不太符合我们的习惯。所以我们改为以下形式。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">[java]&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">view plain</span></a><span style=\"font-size:16px;\">&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">copy</span></a> \n</div>\n<ol>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton(){}&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getInstance(){&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SingletonInstance.instance;&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;class&nbsp;SingletonInstance{&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;Singleton&nbsp;instance&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span> \n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"color:#DF402A;font-size:16px;\">}&nbsp;&nbsp;</span> \n	</li>\n</ol>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;好了，进行到这里，单例模式算是已经完成了。最终的产物就是如上述的形式。上述形式保证了以下几点。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.Singleton最多只有一个实例，在不考虑反射强行突破访问限制的情况下。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.保证了并发访问的情况下，不会发生由于并发而产生多个实例。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.保证了并发访问的情况下，不会由于初始化动作未完全完成而造成使用了尚未正确初始化的实例。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;以下为不太常用的方式，这里给出来只是给各位参考，不建议使用下述方式。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第一种，就是俗称的饿汉式加载。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">[java]&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">view plain</span></a><span style=\"font-size:16px;\">&nbsp;</span><a href=\"http://blog.csdn.net/zuoxiaolong8810/article/details/9005611#\"><span style=\"font-size:16px;\">copy</span></a> \n</div>\n<ol>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Singleton&nbsp;singleton&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton(){}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getInstance(){&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;singleton;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>\n	</li>\n	<li style=\"text-align:left;font-size:14px;\">\n		<span style=\"font-size:16px;\">}&nbsp;&nbsp;</span>\n	</li>\n</ol>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述方式与我们最后一种给出的方式类似，只不过没有经过内部类处理，这种方式最主要的缺点就是一旦我访问了Singleton的任何其他的静态域，就会造成实例的初始化，而事实是可能我们从始至终就没有使用这个实例，造成内存的浪费。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不过在有些时候，直接初始化单例的实例也无伤大雅，对项目几乎没什么影响，比如我们在应用启动时就需要加载的配置文件等，就可以采取这种方式去保证单例。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二种我就不贴了，与双重锁定一模一样，只是给静态的实例属性加上关键字volatile，标识这个属性是不需要优化的。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这样也不会出现实例化发生一半的情况，因为加入了volatile关键字，就等于禁止了JVM自动的指令重排序优化，并且强行保证线程中对变量所做的任何写入操作对其他线程都是即时可见的。这里没有篇幅去介绍volatile以及JVM中变量访问时所做的具体动作，总之volatile会强行将对该变量的所有读和取操作绑定成一个不可拆分的动作。如果读者有兴趣的话，可以自行去找一些资料看一下相关内容。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;不过值得注意的是，volatile关键字是在JDK1.5以及1.5之后才被给予了意义，所以这种方式要在JDK1.5以及1.5之后才可以使用，但仍然还是不推荐这种方式，一是因为代码相对复杂，二是因为由于JDK版本的限制有时候会有诸多不便。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;好了，以上基本上就是常见的所有单例模式的构造方式，如果下次再有面试让你去写一个单例模式，有时间的话就把上面所有的全部写给面试官并一一将优劣讲给他听吧，这样的话估计offer已经离你不远了。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<span style=\"font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本次单例模式的分享就到此结束了，感谢各位的收看。</span>\n</div>\n<div style=\"font-size:14px;\">\n	<br />\n</div>\n<hr />\n<div style=\"font-size:14px;\">\n	<br />\n</div>', '2017-11-27 16:24:50', '', null, null, '单例', '');
